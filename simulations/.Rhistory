})
# Define the elements
elements <- c(1, 2, 3)
# Compute all combinations of 1, 2, and 3 elements
combinations_1 <- combn(elements, 1)
combinations_2 <- combn(elements, 2)
combinations_3 <- combn(elements, 3)
# Combine all the combinations into a single list
all_combinations <- c(combinations_1, combinations_2, combinations_3)
# Filter the combinations to include only those containing "2"
selected_combinations <- lapply(all_combinations, function(comb) {
comb[, apply(comb == 2, 1, any)]
})
lapply(all_combinations, function(comb) {
comb[, apply(comb == 2, 1, any)]
})
# Split the matrix into a list of matrices based on the number of elements in each combination
split_combinations <- split(all_combinations, col(combinations_1, combn(elements, 2), combn(elements, 3)))
# Split the matrix into a list of matrices based on the number of elements in each combination
split_combinations <- split(all_combinations, col(combinations_1, combn(elements, 2), combn(elements, 3)))
for (i in 1:length(all_combinations)) {
comb <- all_combinations[[i]]
selected_combinations[[i]] <- comb[, apply(comb == 2, 1, any)]
}
for (i in 1:length(all_combinations)) {
comb <- all_combinations[[i]]
selected_combinations[[i]] <- comb[, apply(comb == 2, 1, any)]
}
apply(comb == 2, 1, any)
# Filter the combinations to include only those containing "2"
selected_combinations <- list()
for (i in 1:length(all_combinations)) {
comb <- all_combinations[[i]]
selected_combinations[[i]] <- comb[, apply(comb == 2, 1, any)]
}
selected_combinations <- all_combinations[, !apply(all_combinations %in% c(1, 3), 1, any)]
selected_combinations <- all_combinations[, !apply(all_combinations %in% c(1, 3), 1, any)]
apply(all_combinations %in% c(1, 3), 1, any)
apply(all_combinations %in% c(1, 3), 1)
apply(all_combinations %in% c(1, 3), 1, any)
all_combinations %in% c(1, 3)
all_combinations %in% c(1, 3)
all_combinations
# Combine all the combinations into a single list
all_combinations <- c(combinations_1, combinations_2, combinations_3)
all_combinations
# Compute all combinations of 1, 2, and 3 elements
combinations_1 <- combn(elements, 1)
combinations_2 <- combn(elements, 2)
combinations_3 <- combn(elements, 3)
# Combine all the combinations into a single list
all_combinations <- c(combinations_1, combinations_2, combinations_3)
all_combinations
combinations_2 <- combn(elements, 2)
combinations_2
combinations_3 <- combn(elements, 3)
combinations_3
# Load the combn function
library(utils)
# Define the elements
elements <- c(1, 2, 3)
# Compute all combinations of 1, 2, and 3 elements
combinations_1 <- combn(elements, 1)
combinations_2 <- combn(elements, 2)
combinations_3 <- combn(elements, 3)
# Combine all the combinations into a single list
all_combinations <- c(combinations_1, combinations_2, combinations_3)
all_combinations
# Filter the combinations to include only those containing "2"
selected_combinations <- lapply(all_combinations, function(comb) {
comb[, apply(comb == 2, 1, any)]
})
all_combinations
# Load the combn function
library(utils)
# Define the elements
elements <- c(1, 2, 3)
# Compute all combinations of 1, 2, and 3 elements
combinations_1 <- combn(elements, 1)
combinations_2 <- combn(elements, 2)
combinations_3 <- combn(elements, 3)
# Combine all the combinations into a single list
all_combinations <- list(combinations_1, combinations_2, combinations_3)
all_combinations
# Print the results
print(all_combinations)
all_combinations
all_combinations %in% c(1, 3)
combn(elements, 2)
# Compute all combinations of 1, 2, and 3 elements
combinations_1 <- combn(elements, 1)
combn
combinations_1
combinations_2
combinations_3 <- combn(elements, 3)
combinations_3
matrix(combinations_2, c(0,0,0))
matrix(c(combinations_2), c(0,0,0))
c(combinations_2)
matrix(combinations_2)
matrix(combinations_2,ncol=2)
matrix(combinations_2,ncol=2,byrow=T)
rbind(matrix(combinations_2,ncol=2,byrow=T),c(0,0,0))
cbind(matrix(combinations_2,ncol=2,byrow=T),c(0,0,0))
rbind(matrix(combinations_2,ncol=2,byrow=T),c(1,2,3))
hyp=matrix(combinations_2,ncol=2,byrow=T)
hyp=cbind(matrix(combinations_2,ncol=2,byrow=T),c(0,0,0))
hyp=rbind(matrix(combinations_2,ncol=2,byrow=T),c(1,2,3))
hyp=cbind(matrix(combinations_2,ncol=2,byrow=T),c(0,0,0))
hyp
hyp=rbind(hyp,c(1,2,3))
hyp
hyp=matrix(combinations_2,ncol=2,byrow=T)
hyp=cbind(hyp,c(0,0,0))
hyp=rbind(hyp,c(1,2,3))
hyp
hyp=rbind(c(1,0,0),c(0,0,3),c(0,2,0),hyp,c(1,2,3))
hyp
hyp
hyp=rbind(c(1,0,0),c(0,2,0),c(0,0,3),hyp,c(1,2,3))
matrix(1)
matrix(1)
hyp=rbind(c(1,0,0),c(0,2,0),c(0,0,3),hyp,c(1,2,3))
hyp
hyp=matrix(combinations_2,ncol=2,byrow=T)
hyp=cbind(hyp,c(0,0,0))
hyp=rbind(c(1,0,0),c(0,2,0),c(0,0,3),hyp,c(1,2,3))
hyp
hyp%in%1
1:3*c(1,0,0)
c(1:3)*c(1,0,0)
t(1:3)*c(1,0,0)
t(1)*c(1,0,0)
t(1:3)
t(,1:3)
t(1:3)
hyp=rbind(c(1,0,0),c(2,0,0),c(3,0,0),hyp,c(1,2,3))
hyp=matrix(combinations_2,ncol=2,byrow=T)
hyp=cbind(hyp,c(0,0,0))
hyp=rbind(c(1,0,0),c(2,0,0),c(3,0,0),hyp,c(1,2,3))
hyp
hyp%in%1
# Find rows that include the number 1
rows_with_1 <- which(apply(hyp == 1, 1, any))
# Select rows with the number 1
selected_rows <- sample_matrix[rows_with_1, ]
# Find rows that include the number 1
rows_with_1 <- which(apply(hyp == 1, 1, any))
# Select rows with the number 1
selected_rows <- sample_matrix[rows_with_1, ]
# Select rows with the number 1
selected_rows <- hyp[rows_with_1, ]
selected_rows
combinations_1
combinations_2
combinations_3
hyp_closedtest <- function(){
# Define the elements
elements <- c(1, 2, 3)
# Compute all combinations of 1, 2, and 3 elements
combinations_1 <- combn(elements, 1)
combinations_2 <- combn(elements, 2)
combinations_3 <- combn(elements, 3)
hyp=matrix(combinations_2,ncol=2,byrow=T)
hyp=cbind(hyp,c(0,0,0))
hyp=rbind(c(1,0,0),c(2,0,0),c(3,0,0),hyp,c(1,2,3))
hyp
# Find rows that include the number sel
rows_with_1 <- which(apply(hyp == sel, 1, any))
# Select rows with the number sel
selected_rows <- hyp[rows_with_sel, ]
return(selected_rows)
}
#
hyp_closedtest <- function(sel){
# Define the elements
elements <- c(1, 2, 3)
# Compute all combinations of 1, 2, and 3 elements
combinations_1 <- combn(elements, 1)
combinations_2 <- combn(elements, 2)
combinations_3 <- combn(elements, 3)
hyp=matrix(combinations_2,ncol=2,byrow=T)
hyp=cbind(hyp,c(0,0,0))
hyp=rbind(c(1,0,0),c(2,0,0),c(3,0,0),hyp,c(1,2,3))
hyp
# Find rows that include the number sel
rows_with_1 <- which(apply(hyp == sel, 1, any))
# Select rows with the number sel
selected_rows <- hyp[rows_with_sel, ]
return(selected_rows)
}
hyp_closedtest(sel=2)
#
hyp_closedtest <- function(sel){
# Define the elements
elements <- c(1, 2, 3)
# Compute all combinations of 1, 2, and 3 elements
combinations_1 <- combn(elements, 1)
combinations_2 <- combn(elements, 2)
combinations_3 <- combn(elements, 3)
hyp=matrix(combinations_2,ncol=2,byrow=T)
hyp=cbind(hyp,c(0,0,0))
hyp=rbind(c(1,0,0),c(2,0,0),c(3,0,0),hyp,c(1,2,3))
hyp
# Find rows that include the number sel
rows_with_sel <- which(apply(hyp == sel, 1, any))
# Select rows with the number sel
selected_rows <- hyp[rows_with_sel, ]
return(selected_rows)
}
hyp_closedtest(sel=2)
hyp_closedtest(sel=3)
# Hypotheses to test (closed test)
hyp_closedtest <- function(sel){
# Define the elements
elements <- c(1, 2, 3)
# Compute all combinations of 1, 2, and 3 elements
combinations_2 <- combn(elements, 2)
hyp=matrix(combinations_2,ncol=2,byrow=T)
hyp=cbind(hyp,c(0,0,0))
hyp=rbind(c(1,0,0),c(2,0,0),c(3,0,0),hyp,c(1,2,3))
hyp
# Find rows that include the number sel
rows_with_sel <- which(apply(hyp == sel, 1, any))
# Select rows with the number sel
selected_rows <- hyp[rows_with_sel, ]
return(selected_rows)
}
hyp_closedtest(sel=3)
# stage2
db_stage2 = sim_data(n_arms=2, N=N2, mu_6m=mu[c(1,sel)], mu_12m=mu[c(1,sel)]+c(0,1,1,2)[c(1,sel)], sd_y=sd_y)
levels(db_stage2$treat) = levels(db_stage1$treat)[c(1,sel)]
hyp_closedtest(sel=3)
db_stage1$treat
levels(db_stage1$treat)
hyp_closedtest(sel=3)
db_stage1$treat
levels(db_stage1$treat)[1,4]
levels(db_stage1$treat)c(1,4)
levels(db_stage1$treat)[c(1,4)]
subset(db_stage1$treat,levels(db_stage1$treat)[c(1,4)])
subset(db_stage1$treat,db_stage1$treat==levels(db_stage1$treat)[c(1,4)])
subset(db_stage1$treat,db_stage1$treat==levels(db_stage1$treat)[c(1,2,4)])
DunnettTest(x=y_6m, g=treat,
data=subset(db_stage1$treat,db_stage1$treat==levels(db_stage1$treat)[c(1,2,4)]))
DunnettTest(x=y_6m, g=treat,
data=subset(db_stage1$treat,db_stage1$treat==levels(db_stage1$treat)[c(1,2,4)]))
db_hyp=subset(db_stage1$treat,db_stage1$treat==levels(db_stage1$treat)[c(1,2,4)])
DunnettTest(x=db_hyp$y_6m, g=db_hyp$treat)
db_hyp=subset(db_stage1$treat,db_stage1$treat==levels(db_stage1$treat)[c(1,2,4)])
DunnettTest(x=y_6m, g=treat,
data=subset(db_stage1,db_stage1$treat==levels(db_stage1$treat)[c(1,2,4)]))
DunnettTest(x=y_6m, g=treat,
data=subset(db_stage1,db_stage1$treat==levels(db_stage1$treat)[c(1,2,4)]))
subset(db_stage1,db_stage1$treat==levels(db_stage1$treat)[c(1,2,4)])
db_hyp= subset(db_stage1,db_stage1$treat==levels(db_stage1$treat)[c(1,2,4)])
DunnettTest(x=y_6m, g=treat,
data=db_hyp)
DunnettTest(x=db_hyp$y_6m, g=db_hyp$treat)
library(gtools)
elements_1 <- c(0,1,2,3)
hyp_mat <- combinations(n=4, r=3, v=elements_1, set = T, repeats.allowed = T)
selected_rows <- hyp_mat[which(apply(hyp_mat, 1, function(x) sum(x==1)==1 & sum(x==2)<=1 & sum(x==3)<=1)), ]
selected_rows
library(utils)
# Define the elements
elements <- c(1, 2, 3)
# Compute all combinations of 1, 2, and 3 elements
combinations_1 <- combn(elements, 1)
combinations_2 <- combn(elements, 2)
combinations_3 <- combn(elements, 3)
hyp=matrix(combinations_2,ncol=2,byrow=T)
hyp=cbind(hyp,c(0,0,0))
hyp=rbind(c(1,0,0),c(2,0,0),c(3,0,0),hyp,c(1,2,3))
hyp
# Find rows that include the number 1
rows_with_1 <- which(apply(hyp == 1, 1, any))
# Select rows with the number 1
selected_rows <- hyp[rows_with_1, ]
selected_rows
library(utils)
# Define the elements
elements <- c(1, 2, 3)
# Compute all combinations of 1, 2, and 3 elements
combinations_1 <- combn(elements, 1)
combinations_2 <- combn(elements, 2)
combinations_3 <- combn(elements, 3)
hyp=matrix(combinations_2,ncol=2,byrow=T)
hyp=cbind(hyp,c(0,0,0))
hyp=rbind(c(1,0,0),c(2,0,0),c(3,0,0),hyp,c(1,2,3))
hyp
# Find rows that include the number 1
rows_with_1 <- which(apply(hyp == 1, 1, any))
# Select rows with the number 1
selected_rows2 <- hyp[rows_with_1, ]
selected_rows
selected_rows2
hyp_mat
selected_rows <- hyp_mat[which(apply(hyp_mat, 2, function(x) sum(x==1)==1 & sum(x==2)<=1 & sum(x==3)<=1)), ]
selected_rows
selected_rows <- hyp_mat[which(apply(hyp_mat, 1, function(x) sum(x==1)==1 & sum(x==2)<=1 & sum(x==3)<=1)), ]
selected_rows
function(x=hyp_mat[2,]) sum(x==1)==1 & sum(x==2)<=1 & sum(x==3)<=1))
function(x=hyp_mat[2,]) sum(x==1)==1 & sum(x==2)<=1 & sum(x==3)<=1)
function(x=hyp_mat[2,]) sum(x==1)==1 & sum(x==2)<=1 & sum(x==3)<=1
function(x=hyp_mat[2,]){ sum(x==1)==1 & sum(x==2)<=1 & sum(x==3)<=1}
function(x=hyp_mat[2,]){ (sum(x==1)==1 & sum(x==2)<=1 & sum(x==3)<=1)}
# Select rows with the number 1
selected_rows2 <- hyp[rows_with_1, ]
DunnettTest(x=db_hyp$y_6m, g=db_hyp$treat)
get_hyp_mat <- function(n_hypothesis = 3, selected_hypothesis = 1){
elements <- c(rep(0, n_hypothesis), 1:n_hypothesis)
hyp_mat <- unique(combinations(n=length(elements), r=n_hypothesis, v=elements, set = F, repeats.allowed = F))
selected_rows <- hyp_mat[which(apply(hyp_mat == selected_hypothesis, 1, any)), ]
selected_rows
}
get_hyp_mat(3,1)
get_hyp_mat(3,2)
library(multcomp)
?mmm
### attitude towards science data
data("mn6.9", package = "TH.data")
### one model for each item
mn6.9.y1 <- glm(y1 ~ group, family = binomial(),
na.action = na.omit, data = mn6.9)
mn6.9.y2 <- glm(y2 ~ group, family = binomial(),
na.action = na.omit, data = mn6.9)
mn6.9.y3 <- glm(y3 ~ group, family = binomial(),
na.action = na.omit, data = mn6.9)
mn6.9.y4 <- glm(y4 ~ group, family = binomial(),
na.action = na.omit, data = mn6.9)
mmm(mn6.9.y1, mn6.9.y2, mn6.9.y3, mn6.9.y4)
### test all parameters simulaneously
summary(glht(mmm(mn6.9.y1, mn6.9.y2, mn6.9.y3, mn6.9.y4),
mlf(diag(2))))
### test all parameters simulaneously
summary(glht(mmm(mn6.9.y1, mn6.9.y2, mn6.9.y3, mn6.9.y4),
mlf(diag(2))))
### group differences
summary(glht(mmm(mn6.9.y1, mn6.9.y2, mn6.9.y3, mn6.9.y4),
mlf("group2 = 0")))
vcov(mmm(mn6.9.y1, mn6.9.y2, mn6.9.y3, mn6.9.y4))
### test all parameters simulaneously
vcov(glht(mmm(mn6.9.y1, mn6.9.y2, mn6.9.y3, mn6.9.y4),
mlf(diag(2))))
glht(mmm(mn6.9.y1, mn6.9.y2, mn6.9.y3, mn6.9.y4),
mlf(diag(2)))
coef(glht(mmm(mn6.9.y1, mn6.9.y2, mn6.9.y3, mn6.9.y4),
mlf(diag(2))))
vcov(glht(mmm(mn6.9.y1, mn6.9.y2, mn6.9.y3, mn6.9.y4),
mlf(diag(2))))
### test all parameters simulaneously
m <- glht(mmm(mn6.9.y1, mn6.9.y2, mn6.9.y3, mn6.9.y4),
mlf(diag(2)))
summary(m)
cov2cor(vcov(m))
install.packages("parallel")
library(parallel)
detectCores()
availableCores()
setwd("C:/Users/mbofi/Dropbox/CeMSIIS/GitHub/ewhorm_sim/2023-07-simulations")
setwd("C:/Users/mbofi/Dropbox/CeMSIIS/GitHub/ewhorm_sim/simulations")
source("C:/Users/mbofi/Dropbox/CeMSIIS/GitHub/ewhorm_sim/R/aux-functions.R")
source("C:/Users/mbofi/Dropbox/CeMSIIS/GitHub/ewhorm_sim/R/sim_trial.R")
rm(list = ls())
setwd("C:/Users/mbofi/Dropbox/CeMSIIS/GitHub/ewhorm_sim/simulations")
source("C:/Users/mbofi/Dropbox/CeMSIIS/GitHub/ewhorm_sim/R/aux-functions.R")
source("C:/Users/mbofi/Dropbox/CeMSIIS/GitHub/ewhorm_sim/R/sim_trial.R")
source("C:/Users/mbofi/Dropbox/CeMSIIS/GitHub/ewhorm_sim/R/sim_data.R")
# packges needed for this script
library(future)
library(purrr)
library(furrr)
##########################################################
##########################################################
# evaluate trial duration with respect to the rmonth, also assumptions regarding the break between stages
mu=c(0,0,0,0); sigma=matrix(c(0.1,0,0,0.1), nrow = 2, byrow = T)
# Settings
n_arms=4; N1=30*4; N2=30*2; sd_y=0.1; alpha1=0.5
rm(list = ls())
setwd("C:/Users/mbofi/Dropbox/CeMSIIS/GitHub/ewhorm_sim/simulations")
source("C:/Users/mbofi/Dropbox/CeMSIIS/GitHub/ewhorm_sim/R/aux-functions.R")
source("C:/Users/mbofi/Dropbox/CeMSIIS/GitHub/ewhorm_sim/R/sim_trial.R")
source("C:/Users/mbofi/Dropbox/CeMSIIS/GitHub/ewhorm_sim/R/sim_data.R")
# packges needed for this script
library(future)
library(purrr)
library(furrr)
# library(parallel)
# Settings
n_arms=4; N1=30*4; N2=30*2; sd_y=0.1; alpha1=0.5
# mu=c(0,1,2,5);
mu=c(0,0,0,0);
mu_6m=mu; mu_12m=mu
# underlying dependencies
require(mvtnorm)#sim_data function
require(DescTools)#aux functions
require(gtools)#aux functions
##########################################################
##########################################################
# evaluate trial duration with respect to the rmonth, also assumptions regarding the break between stages
mu=c(0,0,0,0); sigma=matrix(c(0.1,0,0,0.1), nrow = 2, byrow = T)
# stage1
db_stage1 = sim_data(n_arms=n_arms, N=N1, mu_6m=mu_6m, mu_12m=mu_12m, sigma=sigma, rmonth=rmonth)
##########################################################
##########################################################
# evaluate trial duration with respect to the rmonth, also assumptions regarding the break between stages
mu=c(0,0,0,0); sigma=matrix(c(0.1,0,0,0.1), nrow = 2, byrow = T); rmonth=10
# stage1
db_stage1 = sim_data(n_arms=n_arms, N=N1, mu_6m=mu_6m, mu_12m=mu_12m, sigma=sigma, rmonth=rmonth)
db_stage1
res_stage1 = DunnettTest(x=db_stage1$y_6m, g=db_stage1$treat)
res_stage1
# (pval_dunnet)
# sum(pval_dunnet>alpha1)
# Selection
# Arms indicators: 1: Low; 2: Medium, 3:High
#--- Worst case: No trend is seen in any of the doses (e.g., all p> alpha1): select highest dose
if(sum(pval_dunnet>alpha1)==3){
sel=3
}
sel
# stage1
db_stage1 = sim_data(n_arms=n_arms, N=N1, mu_6m=mu_6m, mu_12m=mu_12m, sigma=sigma, rmonth=rmonth)
res_stage1 = DunnettTest(x=db_stage1$y_6m, g=db_stage1$treat)
pval_dunnet = res_stage1$Placebo[,4]
# (pval_dunnet)
# sum(pval_dunnet>alpha1)
# Selection
# Arms indicators: 1: Low; 2: Medium, 3:High
#--- Worst case: No trend is seen in any of the doses (e.g., all p> alpha1): select highest dose
if(sum(pval_dunnet>alpha1)==3){
sel=3
}
#--- Intermediate case: some doses show a trend: select the lowest effective dose, no new recruitment for the other doses
if(sum(pval_dunnet<alpha1)<3 & sum(pval_dunnet<alpha1)>=1){
sel=which(pval_dunnet<alpha1)[1]
}
#--- Intermediate case 2: some doses show a trend: select the (highest) effective dose, no new recruitment for the other doses
# if(sum(pval_dunnet<alpha1)<3){
#   sel=which.min(pval_dunnet)+1
# }
#--- Best case: All doses show a trend: select the lowest effective dose, no new recruitment for the other doses
if(sum(pval_dunnet<alpha1)==3){
sel=1
}
sel <- sel+1
hyp <- get_hyp_mat(3,sel-1)
hyp <- hyp + (hyp != 0)
sel
sset_hyp1 <- subset(db_stage1,db_stage1$treat==levels(db_stage1$treat)[c(1,hyp[1,][hyp[1,] != 0])])
sset_hyp2 <- subset(db_stage1,db_stage1$treat==levels(db_stage1$treat)[c(1,hyp[2,][hyp[2,] != 0])])
sset_hyp3 <- subset(db_stage1,db_stage1$treat==levels(db_stage1$treat)[c(1,hyp[3,][hyp[3,] != 0])])
sset_hyp4 <- subset(db_stage1,db_stage1$treat==levels(db_stage1$treat)[c(1,hyp[4,][hyp[4,] != 0])])
# pvalues closed test
DunnettTest(x=sset_hyp1$y_12m, g=sset_hyp1$treat)
# pvalues closed test
pvalue_Dunnett1 <- DunnettTest(x=sset_hyp1$y_12m, g=sset_hyp1$treat)
pvalue_Dunnett1$Placebo
pvalue_Dunnett1$Placebo[4]
max(pvalue_Dunnett1$Placebo[4])
# pvalues closed test
pvalue_Dunnett1 <- (DunnettTest(x=sset_hyp1$y_12m, g=sset_hyp1$treat)$Placebo[4])
pvalue_Dunnett1
pvalue_Dunnett2 <- (DunnettTest(x=sset_hyp2$y_12m, g=sset_hyp2$treat)$Placebo[4])
pvalue_Dunnett2
DunnettTest(x=sset_hyp2$y_12m, g=sset_hyp2$treat)
DunnettTest(x=sset_hyp2$y_12m, g=sset_hyp2$treat)$Placebo
DunnettTest(x=sset_hyp2$y_12m, g=sset_hyp2$treat)$Placebo[4]
DunnettTest(x=sset_hyp2$y_12m, g=sset_hyp2$treat)$Placebo
DunnettTest(x=sset_hyp2$y_12m, g=sset_hyp2$treat)$Placebo[4,]
DunnettTest(x=sset_hyp2$y_12m, g=sset_hyp2$treat)$Placebo[,4]
pvalue_Dunnett3 <- (DunnettTest(x=sset_hyp3$y_12m, g=sset_hyp3$treat)$Placebo[4])
DunnettTest(x=sset_hyp3$y_12m, g=sset_hyp3$treat)
DunnettTest(x=sset_hyp3$y_12m, g=sset_hyp3$treat)$Placebo[,4]
# pvalues closed test
pvalue_Dunnett1 <- (DunnettTest(x=sset_hyp1$y_12m, g=sset_hyp1$treat)$Placebo[,4])
DunnettTest(x=sset_hyp1$y_12m, g=sset_hyp1$treat)$
DunnettTest(x=sset_hyp1$y_12m, g=sset_hyp1$treat)
DunnettTest(x=sset_hyp1$y_12m, g=sset_hyp1$treat)$Placebo[,4]
DunnettTest(x=sset_hyp4$y_12m, g=sset_hyp4$treat)$Placebo[,4]
DunnettTest(x=sset_hyp4$y_12m, g=sset_hyp4$treat)
max(DunnettTest(x=sset_hyp4$y_12m, g=sset_hyp4$treat)$Placebo[,4])
min(DunnettTest(x=sset_hyp4$y_12m, g=sset_hyp4$treat)$Placebo[,4])
#
pvalue_stage1 <- max(pvalue_Dunnett1,pvalue_Dunnett2,pvalue_Dunnett3,pvalue_Dunnett4)
(runif(1)>0.9)
(runif(1)>0.9)
(runif(1)>0.9)
(runif(1)>0.9)
(runif(1)>0.9)
replicate(10,runif(1)>0.9)
replicate(1000,runif(1)>0.9)
sum(replicate(1000,runif(1)>0.9))/1000
sum(replicate(1000,runif(1)<0.9))/1000
sum(replicate(1000,runif(1)<0.9))/1000
sum(replicate(1000,runif(1)<0.9))/1000
# Safety
p_safety=c(0.9,0.8,0.7)
if(safety==T){
safety_dose1 <- (runif(1)<p_safety[1])
safety_dose2 <- (runif(1)<p_safety[2])
safety_dose3 <- (runif(1)<p_safety[3])
}
# Safety
p_safety=c(0.9,0.8,0.7)
safety_dose1 <- (runif(1)<p_safety[1])
safety_dose2 <- (runif(1)<p_safety[2])
safety_dose3 <- (runif(1)<p_safety[3])
c(safety_dose1,safety_dose2,safety_dose3)
# if safety_dosei is true, then consider safe
safety=c(safety_dose1,safety_dose2,safety_dose3)
