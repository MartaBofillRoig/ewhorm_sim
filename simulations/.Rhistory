stage2
sum(res_decision$dec)/n_trials
# Run simulations
# Set a specific seed for reproducibility
set.seed(526)
# Set the number of trials to run and other parameters
n_trials <- 100000
# n_trials <- 100
# n_cores <- detectCores()-1  # Adjust the number of cores based on your machine's capabilities
n_cores <- availableCores()-1
# Set up the "multicore" future plan
# plan(multicore, workers = n_cores)
plan(multisession, workers = n_cores)
# Run the simulations in parallel using future_map
results_list <- future_map(1:n_trials, function(i) sim_trial_pce(n_arms=4, N1=30*4, N2=30*2, mu_6m=mu, mu_12m=mu, sigma=sg_m, rmonth=2, alpha1=0.1, alpha=0.05, sim_out=T), .options=furrr_options(seed = TRUE))
#
# Using simplified output
stage2 = data.frame(stage2_arm1=c(0),stage2_arm2=c(0),stage2_arm3=c(0))
for(i in 1:n_trials){stage2[i,]<-results_list[[i]]$stage2_arms}
stage2
res_decision = data.frame(dec1=c(0),dec2=c(0),dec3=c(0))
for(i in 1:n_trials){res_decision[i,]<-results_list[[i]]$simdec_output}
x <- unlist(lapply(l, function(element) element$simdec_output))
x <- unlist(lapply(results_list, function(element) element$simdec_output))
x
x <- matrix(unlist(lapply(results_list, function(element) element$simdec_output)),ncol = 3)
x
simdec_output
results_list
for(i in 1:10){res_decision[i,]<-results_list[[i]]$simdec_output}
res_decision
results_list
results_list[[1]]
x
results_list[[13]]
x <- matrix(unlist(lapply(results_list, function(element) element$simdec_output)),ncol = 3,byrow = T)
x
x[13,]
x[74,]
results_list[[74]]
res_decision
results_list[[74]]
res_decision[,4]=res_decision[,1]+res_decision[,2]+res_decision[,3]
res_decision
res_decision[,4] = ifelse(res_decision[,1]+res_decision[,2]+res_decision[,3]>=1,1,0)
res_decision
res_decision[,4] = ifelse(res_decision[,1]+res_decision[,2]+res_decision[,3]>=1,1,0,na.omit(T))
res_decision[,4] = ifelse(res_decision[,1]+res_decision[,2]+res_decision[,3]>=1
&& is.na(res_decision[,1]+res_decision[,2]+res_decision[,3])==F,
1,0)
res_decision[,4] = ifelse(res_decision[,1]+res_decision[,2]+res_decision[,3]>=1
& is.na(res_decision[,1]+res_decision[,2]+res_decision[,3])==F,
1,0)
res_decision
sum(res_decision[,4])/n_trials
sum(res_decision[,4])/n_trials
res_stage2 = matrix(unlist(lapply(results_list, function(element) element$stage2_arms)),
ncol = 3, byrow = T)
res_stage2
table(res_stage2)
c(sum(res_stage2[1,]), sum(res_stage2[2,]), sum(res_stage2[3,]))/n_trials
sum(res_stage2[1,])
res_stage2[1,]
res_stage2[,1]
c(sum(res_stage2[,1]), sum(res_stage2[,1]), sum(res_stage2[,3]))/n_trials
which.min(c(sum(res_stage2[,1]), sum(res_stage2[,1]), sum(res_stage2[,3]))/n_trials)
which.max(c(sum(res_stage2[,1]), sum(res_stage2[,1]), sum(res_stage2[,3]))/n_trials)
pval_dunnett
which.min(pval_dunnett)
# Function to simulate trial data (2-stages, with dose selection)
sim_trial_pce <- function(n_arms=4, N1=30*4, N2=30*2, mu_6m, mu_12m, sigma, rmonth, alpha1=0.1, alpha=0.05, sim_out=F){
#######################################
# stage1
db_stage1 = sim_data(n_arms=n_arms-1, N=N1, mu_6m=mu_6m[1:n_arms-1], mu_12m=mu_12m[1:n_arms-1], sigma=sigma, rmonth=rmonth)
recruit_time1 = max(db_stage1$recruit_time)
model_aov = aov(y_6m ~ treat, db_stage1)
model_dunnett = summary(glht(model = model_aov, linfct=mcp(treat="Dunnett"), alternative = "less"))
pval_dunnett = model_dunnett$test$pvalues
#######################################
# decisions based on pvalues from Dunnett test at 6 month
if(sum(pval_dunnett<alpha1)==2){sc=2;sel=2:3}
if(sum(pval_dunnett<alpha1)==1){sc=1;sel=which.min(pval_dunnett)+1}
if(sum(pval_dunnett<alpha1)==0){sc=0;sel=0}
#######################################
# pvalues ttest 12 months
pval <- c()
for(j in 1:(n_arms-2)){
sub1 = subset(db_stage1,(db_stage1$treat==levels(db_stage1$treat)[1])+(db_stage1$treat==levels(db_stage1$treat)[j+1])==1)
mod1 = lm(y_12m ~ treat, sub1)
res1 = summary(mod1)
pval[j] <- pt(coef(res1)[2,3], mod1$df, lower.tail = FALSE)
}
z = qnorm(1-pval)
decision_s1 <- c()
decision_s1[1] = ifelse(pval[1]<alpha1, "Reject", "Accept")
decision_s1[2] = ifelse(pval[2]<alpha1, "Reject", "Accept")
decision_stage1 = data.frame(decision_s1, row.names = levels(db_stage1$treat)[2:3])
#######################################
# preplanning adaptive conditional error
N=N1+N2
graph_bh <- BonferroniHolm(3)
# the package assumes that wj are equal for all j
v <- c(1/2,1/2,0)
z1 <- c(z,0)
preplan <- doInterim(graph=graph_bh,z1=z1,v=v,alpha=alpha)
# preplan@Aj
# preplan@BJ
#######################################
# stage2
# sc=2 --> Arm A and B continue to stage 2
# sc=1 --> Arm A or B continue to stage 2
# sc=0 --> Arm A and B stop and do not continue to stage 2
if(sc==2){
db_stage2 = sim_data(n_arms=3, N=N2, mu_6m=mu_6m[c(1,2,3)], mu_12m=mu_12m[c(1,2,3)], sigma=sigma, rmonth=rmonth)
levels(db_stage2$treat) = levels(db_stage1$treat)[c(1,2,3)]
recruit_time2 = max(db_stage2$recruit_time)
pval2 <- c()
for(j in 1:2){
sub2 = subset(db_stage2,(db_stage2$treat==levels(db_stage2$treat)[1])+(db_stage2$treat==levels(db_stage2$treat)[j+1])==1)
mod2 = lm(y_12m ~ treat, sub2) #are we using this model or should we use individual models?
res2 = summary(mod2)
pval2[j] <- pt(coef(res2)[2,3], mod2$df, lower.tail = FALSE)
}
Avalues <- c(preplan@BJ[7]/2, #H123
preplan@BJ[6], #H12
preplan@BJ[5], #H13
preplan@BJ[3], #H23
preplan@BJ[2], #H2
preplan@BJ[4]  #H1
)
# pval2[1] <= Avalues[c(1,2,3,6)] #p1
# pval2[2] <= Avalues[c(1,2,4,5)] #p2
# decision_stage2 = matrix(c(pval2[1] <= Avalues[c(1,2,3,6)],
#                            pval2[2] <= Avalues[c(1,2,4,5)]),
#                            byrow = F, ncol = 2)
decision <- c()
decision[1] = ifelse(sum(pval2[1] <= Avalues[c(1,2,3,6)])==4, "Reject", "Accept")
decision[2] = ifelse(sum(pval2[2] <= Avalues[c(1,2,4,5)])==4, "Reject", "Accept")
#
decision_stage2 = data.frame(decision, row.names = levels(db_stage2$treat)[2:3])
pval2 = data.frame(pval2, row.names = levels(db_stage2$treat)[2:3])
stage2_arms = c(1,1,0)
simdec_output = c(ifelse(decision[1]=="Reject", 1, 0),
ifelse(decision[2]=="Reject", 1, 0),
NA)
}
if(sc==1){
db_stage2 = sim_data(n_arms=3, N=N2, mu_6m=mu_6m[c(1,sel,4)], mu_12m=mu_12m[c(1,sel,4)], sigma=sigma, rmonth=rmonth)
levels(db_stage2$treat) = c(levels(db_stage1$treat)[c(1,sel)],"High")
recruit_time2 = max(db_stage2$recruit_time)
pval2 <- c()
for(j in 1:2){
sub2 = subset(db_stage2,(db_stage2$treat==levels(db_stage2$treat)[1])+(db_stage2$treat==levels(db_stage2$treat)[j+1])==1)
mod2 = lm(y_12m ~ treat, sub2) #are we using this model or should we use individual models?
res2 = summary(mod2)
pval2[j] <- pt(coef(res2)[2,3], mod2$df, lower.tail = FALSE)
}
Avalues <- c(preplan@BJ[7]/2, #H123
preplan@BJ[6], #H12
preplan@BJ[5], #H13
preplan@BJ[3], #H23
preplan@BJ[2], #H2
preplan@BJ[1]  #H3
)
# pval2[1] <= Avalues[c(1,2,4,5)] #p2
# pval2[2] <= Avalues[c(1,3,4,6)] #p3
# decision_stage2 = matrix(c(pval2[1] <= Avalues[c(1,2,4,5)],
#                            pval2[2] <= Avalues[c(1,3,4,6)]),
#                            byrow = F, ncol = 2)
decision <- c()
dec1 <- sum(pval2[1] <= Avalues[c(1,2,4,5)])
dec2 <- sum(pval2[2] <= Avalues[c(1,3,4,6)])
decision[1] = ifelse(dec1==4, "Reject", "Accept")
decision[2] = ifelse(dec2==4, "Reject", "Accept")
#
decision_stage2 = data.frame(decision, row.names = levels(db_stage2$treat)[2:3])
pval2 = data.frame(pval2, row.names = levels(db_stage2$treat)[2:3])
if(sel==2){stage2_arms = c(1,0,1)}
if(sel==3){stage2_arms = c(0,1,1)}
simdec_output = c(0,
ifelse(decision[1]=="Reject", 1, 0),
ifelse(decision[2]=="Reject", 1, 0))
}
if(sc==0){
db_stage2 = sim_data(n_arms=2, N=N2, mu_6m=mu_6m[c(1,4)], mu_12m=mu_12m[c(1,4)], sigma=sigma, rmonth=rmonth)
levels(db_stage2$treat) = c(levels(db_stage1$treat)[c(1)],"High")
recruit_time2 = max(db_stage2$recruit_time)
mod2 = lm(y_12m ~ treat, db_stage2) #are we using this model or should we use individual models?
res2 = summary(mod2)
pval2 <- pt(coef(res2)[2,3], mod2$df, lower.tail = FALSE)
Avalues <- c(preplan@BJ[7], #H123
preplan@BJ[5], #H13
preplan@BJ[3], #H23
preplan@BJ[1]  #H3
)
decision_stage2 = matrix(pval2 <= Avalues, ncol = 1) #p3
decision <- c()
decision[1] = ifelse(sum(pval2 <= Avalues)==4, "Reject", "Accept")
#
decision_stage2 = data.frame(decision, row.names = levels(db_stage2$treat)[2])
pval2 = data.frame(pval2, row.names = levels(db_stage2$treat)[2])
stage2_arms = c(0,0,1)
simdec_output = c(0, 0,
ifelse(decision[1]=="Reject", 1, 0))
}
#######################################
if(sim_out==F){
return(list(pvalue_stage1=pval,
pvalue_stage2=pval2,
sc=sc,
decision_stage1=decision_stage1,
decision_stage2=decision_stage2,
critical_values=preplan,
selected_dose=sel,
recruit_time1=recruit_time1,
recruit_time2=recruit_time2))
}else{
return(list(stage2_arms=stage2_arms,
simdec_output=simdec_output))
}
}
# Run simulations
# Set a specific seed for reproducibility
set.seed(526)
# Set the number of trials to run and other parameters
n_trials <- 10000
# n_trials <- 100
# n_cores <- detectCores()-1  # Adjust the number of cores based on your machine's capabilities
n_cores <- availableCores()-1
# Set up the "multicore" future plan
# plan(multicore, workers = n_cores)
plan(multisession, workers = n_cores)
# Run the simulations in parallel using future_map
results_list <- future_map(1:n_trials, function(i) sim_trial_pce(n_arms=4, N1=30*4, N2=30*2, mu_6m=mu, mu_12m=mu, sigma=sg_m, rmonth=2, alpha1=0.1, alpha=0.05, sim_out=T), .options=furrr_options(seed = TRUE))
# Using simplified output
res_stage2 = matrix(unlist(lapply(results_list, function(element) element$stage2_arms)),
ncol = 3, byrow = T)
c(sum(res_stage2[,1]), sum(res_stage2[,1]), sum(res_stage2[,3]))/n_trials
#
res_decision = matrix(unlist(lapply(results_list, function(element) element$simdec_output)),
ncol = 3, byrow = T)
res_decision[,4] = ifelse(res_decision[,1]+res_decision[,2]+res_decision[,3]>=1
& is.na(res_decision[,1]+res_decision[,2]+res_decision[,3])==F,
1, 0)
res_decision = matrix(unlist(lapply(results_list, function(element) element$simdec_output)),
ncol = 3, byrow = T)
res_decision
res_decision[,4] = ifelse(res_decision[,1]+res_decision[,2]+res_decision[,3] >= 1
& is.na(res_decision[,1]+res_decision[,2]+res_decision[,3])==F,
1, 0)
is.na(res_decision[,1]+res_decision[,2]+res_decision[,3])
res_decision[,1]+res_decision[,2]+res_decision[,3] >= 1
res_decision[,4] = ifelse(res_decision[,1]+res_decision[,2]+res_decision[,3] >= 1
& is.na(res_decision[,1]+res_decision[,2]+res_decision[,3])==F,
1, 0)
res_decision[,4] = ifelse(res_decision[,1]+res_decision[,2]+res_decision[,3] >= 1,
1, 0)
res_decision[,4] = ifelse(res_decision[,1]+res_decision[,2]+res_decision[,3] >= 1,
1, 0)
res_decision = matrix(unlist(lapply(results_list, function(element) element$simdec_output)),
ncol = 3, byrow = T)
res_decision
res_decision[,4] = res_decision[,1]
res_decision[,4] = ifelse(res_decision[,1]+res_decision[,2]+res_decision[,3] >= 1
& is.na(res_decision[,1]+res_decision[,2]+res_decision[,3])==F,
1, 0)
res_decision[,4] = res_decision[,1]
res_decision[,4] = res_decision[,1]
res_decision = matrix(unlist(lapply(results_list, function(element) element$simdec_output)),
ncol = 3, byrow = T)
res_decision[,4] = res_decision[,1]
res_decision
res_decision[,4] <- res_decision[,1]
res_decision[,4] = res_decision[,1]
res_decision = matrix(unlist(lapply(results_list, function(element) element$simdec_output)),
ncol = 3, byrow = T)
res_decision4 = ifelse(res_decision[,1]+res_decision[,2]+res_decision[,3] >= 1
& is.na(res_decision[,1]+res_decision[,2]+res_decision[,3])==F,
1, 0)
res_decision4 = ifelse(res_decision[,1]+res_decision[,2]+res_decision[,3] >= 1
& is.na(res_decision[,1]+res_decision[,2]+res_decision[,3])==F,
1, 0)
res_decision <- cbind(res_decision, res_decision4)
res_decision
sum(res_decision[,4])/n_trials
# Run simulations
# Set a specific seed for reproducibility
set.seed(5267)
# Set the number of trials to run and other parameters
n_trials <- 10000
# n_trials <- 100
# n_cores <- detectCores()-1  # Adjust the number of cores based on your machine's capabilities
n_cores <- availableCores()-1
# Set up the "multicore" future plan
# plan(multicore, workers = n_cores)
plan(multisession, workers = n_cores)
# Run the simulations in parallel using future_map
results_list <- future_map(1:n_trials, function(i) sim_trial_pce(n_arms=4, N1=30*4, N2=30*2, mu_6m=mu, mu_12m=mu, sigma=sg_m, rmonth=2, alpha1=0.1, alpha=0.05, sim_out=T), .options=furrr_options(seed = TRUE))
# Using simplified output
res_stage2 = matrix(unlist(lapply(results_list, function(element) element$stage2_arms)),
ncol = 3, byrow = T)
c(sum(res_stage2[,1]), sum(res_stage2[,1]), sum(res_stage2[,3]))/n_trials
#
res_decision = matrix(unlist(lapply(results_list, function(element) element$simdec_output)),
ncol = 3, byrow = T)
res_decision4 = ifelse(res_decision[,1]+res_decision[,2]+res_decision[,3] >= 1
& is.na(res_decision[,1]+res_decision[,2]+res_decision[,3])==F,
1, 0)
res_decision <- cbind(res_decision, res_decision4)
sum(res_decision[,4])/n_trials
# Function to simulate trial data (2-stages, with dose selection)
sim_trial_pce <- function(n_arms=4, N1=30*4, N2=30*2, mu_6m, mu_12m, sigma, rmonth, alpha1=0.1, alpha=0.05, sim_out=F){
#######################################
# stage1
db_stage1 = sim_data(n_arms=n_arms-1, N=N1, mu_6m=mu_6m[1:n_arms-1], mu_12m=mu_12m[1:n_arms-1], sigma=sigma, rmonth=rmonth)
recruit_time1 = max(db_stage1$recruit_time)
model_aov = aov(y_6m ~ treat, db_stage1)
model_dunnett = summary(glht(model = model_aov, linfct=mcp(treat="Dunnett"), alternative = "less"))
pval_dunnett = model_dunnett$test$pvalues
#######################################
# decisions based on pvalues from Dunnett test at 6 month
if(sum(pval_dunnett<alpha1)==2){sc=2;sel=2:3}
if(sum(pval_dunnett<alpha1)==1){sc=1;sel=which.min(pval_dunnett)+1}
if(sum(pval_dunnett<alpha1)==0){sc=0;sel=0}
#######################################
# pvalues ttest 12 months
pval <- c()
for(j in 1:(n_arms-2)){
sub1 = subset(db_stage1,(db_stage1$treat==levels(db_stage1$treat)[1])+(db_stage1$treat==levels(db_stage1$treat)[j+1])==1)
mod1 = lm(y_12m ~ treat, sub1)
res1 = summary(mod1)
pval[j] <- pt(coef(res1)[2,3], mod1$df, lower.tail = FALSE)
}
z = qnorm(1-pval)
decision_s1 <- c()
decision_s1[1] = ifelse(pval[1]<alpha1, "Reject", "Accept")
decision_s1[2] = ifelse(pval[2]<alpha1, "Reject", "Accept")
decision_stage1 = data.frame(decision_s1, row.names = levels(db_stage1$treat)[2:3])
#######################################
# preplanning adaptive conditional error
N=N1+N2
graph_bh <- BonferroniHolm(3)
# the package assumes that wj are equal for all j
v <- c(1/2,1/2,0)
z1 <- c(z,0)
preplan <- doInterim(graph=graph_bh,z1=z1,v=v,alpha=alpha)
# preplan@Aj
# preplan@BJ
#######################################
# stage2
# sc=2 --> Arm A and B continue to stage 2
# sc=1 --> Arm A or B continue to stage 2
# sc=0 --> Arm A and B stop and do not continue to stage 2
if(sc==2){
db_stage2 = sim_data(n_arms=3, N=N2, mu_6m=mu_6m[c(1,2,3)], mu_12m=mu_12m[c(1,2,3)], sigma=sigma, rmonth=rmonth)
levels(db_stage2$treat) = levels(db_stage1$treat)[c(1,2,3)]
recruit_time2 = max(db_stage2$recruit_time)
pval2 <- c()
for(j in 1:2){
sub2 = subset(db_stage2,(db_stage2$treat==levels(db_stage2$treat)[1])+(db_stage2$treat==levels(db_stage2$treat)[j+1])==1)
mod2 = lm(y_12m ~ treat, sub2) #are we using this model or should we use individual models?
res2 = summary(mod2)
pval2[j] <- pt(coef(res2)[2,3], mod2$df, lower.tail = FALSE)
}
Avalues <- c(preplan@BJ[7]/2, #H123
preplan@BJ[6], #H12
preplan@BJ[5], #H13
preplan@BJ[3], #H23
preplan@BJ[2], #H2
preplan@BJ[4]  #H1
)
# pval2[1] <= Avalues[c(1,2,3,6)] #p1
# pval2[2] <= Avalues[c(1,2,4,5)] #p2
# decision_stage2 = matrix(c(pval2[1] <= Avalues[c(1,2,3,6)],
#                            pval2[2] <= Avalues[c(1,2,4,5)]),
#                            byrow = F, ncol = 2)
decision <- c()
decision[1] = ifelse(sum(pval2[1] <= Avalues[c(1,2,3,6)])==4, "Reject", "Accept")
decision[2] = ifelse(sum(pval2[2] <= Avalues[c(1,2,4,5)])==4, "Reject", "Accept")
#
decision_stage2 = data.frame(decision, row.names = levels(db_stage2$treat)[2:3])
pval2 = data.frame(pval2, row.names = levels(db_stage2$treat)[2:3])
stage2_arms = c(1,1,0)
simdec_output = c(ifelse(decision[1]=="Reject", 1, 0),
ifelse(decision[2]=="Reject", 1, 0),
NA)
}
if(sc==1){
db_stage2 = sim_data(n_arms=3, N=N2, mu_6m=mu_6m[c(1,sel,4)], mu_12m=mu_12m[c(1,sel,4)], sigma=sigma, rmonth=rmonth)
levels(db_stage2$treat) = c(levels(db_stage1$treat)[c(1,sel)],"High")
recruit_time2 = max(db_stage2$recruit_time)
pval2 <- c()
for(j in 1:2){
sub2 = subset(db_stage2,(db_stage2$treat==levels(db_stage2$treat)[1])+(db_stage2$treat==levels(db_stage2$treat)[j+1])==1)
mod2 = lm(y_12m ~ treat, sub2) #are we using this model or should we use individual models?
res2 = summary(mod2)
pval2[j] <- pt(coef(res2)[2,3], mod2$df, lower.tail = FALSE)
}
Avalues <- c(preplan@BJ[7]/2, #H123
preplan@BJ[6], #H12
preplan@BJ[5], #H13
preplan@BJ[3], #H23
preplan@BJ[2], #H2
preplan@BJ[1]  #H3
)
# pval2[1] <= Avalues[c(1,2,4,5)] #p2
# pval2[2] <= Avalues[c(1,3,4,6)] #p3
# decision_stage2 = matrix(c(pval2[1] <= Avalues[c(1,2,4,5)],
#                            pval2[2] <= Avalues[c(1,3,4,6)]),
#                            byrow = F, ncol = 2)
decision <- c()
dec1 <- sum(pval2[1] <= Avalues[c(1,2,4,5)])
dec2 <- sum(pval2[2] <= Avalues[c(1,3,4,6)])
decision[1] = ifelse(dec1==4, "Reject", "Accept")
decision[2] = ifelse(dec2==4, "Reject", "Accept")
#
decision_stage2 = data.frame(decision, row.names = levels(db_stage2$treat)[2:3])
pval2 = data.frame(pval2, row.names = levels(db_stage2$treat)[2:3])
if(sel==2){stage2_arms = c(1,0,1)}
if(sel==3){stage2_arms = c(0,1,1)}
simdec_output = c(0,
ifelse(decision[1]=="Reject", 1, 0),
ifelse(decision[2]=="Reject", 1, 0))
}
if(sc==0){
db_stage2 = sim_data(n_arms=2, N=N2, mu_6m=mu_6m[c(1,4)], mu_12m=mu_12m[c(1,4)], sigma=sigma, rmonth=rmonth)
levels(db_stage2$treat) = c(levels(db_stage1$treat)[c(1)],"High")
recruit_time2 = max(db_stage2$recruit_time)
mod2 = lm(y_12m ~ treat, db_stage2) #are we using this model or should we use individual models?
res2 = summary(mod2)
pval2 <- pt(coef(res2)[2,3], mod2$df, lower.tail = FALSE)
Avalues <- c(preplan@BJ[7], #H123
preplan@BJ[5], #H13
preplan@BJ[3], #H23
preplan@BJ[1]  #H3
)
decision_stage2 = matrix(pval2 <= Avalues, ncol = 1) #p3
decision <- c()
decision[1] = ifelse(sum(pval2 <= Avalues)==4, "Reject", "Accept")
#
decision_stage2 = data.frame(decision, row.names = levels(db_stage2$treat)[2])
pval2 = data.frame(pval2, row.names = levels(db_stage2$treat)[2])
stage2_arms = c(0,0,1)
simdec_output = c(0, 0,
ifelse(decision[1]=="Reject", 1, 0))
}
#######################################
if(sim_out==F){
return(list(pvalue_stage1=pval,
pvalue_stage2=pval2,
sc=sc,
decision_stage1=decision_stage1,
decision_stage2=decision_stage2,
critical_values=preplan,
selected_dose=sel,
recruit_time1=recruit_time1,
recruit_time2=recruit_time2))
}else{
return(list(stage2_arms=stage2_arms,
simdec_output=simdec_output))
}
}
# Run simulations
# Set a specific seed for reproducibility
set.seed(5267)
# Set the number of trials to run and other parameters
n_trials <- 10000
# n_trials <- 100
# n_cores <- detectCores()-1  # Adjust the number of cores based on your machine's capabilities
n_cores <- availableCores()-1
# Set up the "multicore" future plan
# plan(multicore, workers = n_cores)
plan(multisession, workers = n_cores)
# Run the simulations in parallel using future_map
results_list <- future_map(1:n_trials, function(i) sim_trial_pce(n_arms=4, N1=30*4, N2=30*2, mu_6m=mu, mu_12m=mu, sigma=sg_m, rmonth=2, alpha1=0.1, alpha=0.05, sim_out=T), .options=furrr_options(seed = TRUE))
# Using simplified output
res_stage2 = matrix(unlist(lapply(results_list, function(element) element$stage2_arms)),
ncol = 3, byrow = T)
c(sum(res_stage2[,1]), sum(res_stage2[,1]), sum(res_stage2[,3]))/n_trials
#
res_decision = matrix(unlist(lapply(results_list, function(element) element$simdec_output)),
ncol = 3, byrow = T)
res_decision4 = ifelse(res_decision[,1]+res_decision[,2]+res_decision[,3] >= 1
& is.na(res_decision[,1]+res_decision[,2]+res_decision[,3])==F,
1, 0)
res_decision <- cbind(res_decision, res_decision4)
sum(res_decision[,4])/n_trials
# Run simulations
# Set a specific seed for reproducibility
set.seed(5267)
# Set the number of trials to run and other parameters
n_trials <- 100000
# n_trials <- 100
# n_cores <- detectCores()-1  # Adjust the number of cores based on your machine's capabilities
n_cores <- availableCores()-1
# Set up the "multicore" future plan
# plan(multicore, workers = n_cores)
plan(multisession, workers = n_cores)
# Run the simulations in parallel using future_map
results_list <- future_map(1:n_trials, function(i) sim_trial_pce(n_arms=4, N1=30*4, N2=30*2, mu_6m=mu, mu_12m=mu, sigma=sg_m, rmonth=2, alpha1=0.1, alpha=0.05, sim_out=T), .options=furrr_options(seed = TRUE))
# Using simplified output
res_stage2 = matrix(unlist(lapply(results_list, function(element) element$stage2_arms)),
ncol = 3, byrow = T)
c(sum(res_stage2[,1]), sum(res_stage2[,1]), sum(res_stage2[,3]))/n_trials
#
res_decision = matrix(unlist(lapply(results_list, function(element) element$simdec_output)),
ncol = 3, byrow = T)
res_decision4 = ifelse(res_decision[,1]+res_decision[,2]+res_decision[,3] >= 1
& is.na(res_decision[,1]+res_decision[,2]+res_decision[,3])==F,
1, 0)
res_decision <- cbind(res_decision, res_decision4)
sum(res_decision[,4])/n_trials
